#!/usr/bin/python
#main browser file (url fetcher, GUI wrapper, main window thread)
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os,os.path
path=os.path.realpath(__file__).rsplit(os.sep,1)[0]+"/modules"
sys.path.append(path)
import gc,unidecode
import locale
locale.setlocale(locale.LC_ALL,"")
import inspect
import re,time,curses,curses.ascii,sys,Queue,utils,threading,traceback,string,hashlib,shelve,warnings,urlparse,binascii,urllib
import StringIO as stringio
import mozCom
from guiObjects import *
from utils import log
profiler=0
import guiTree

if "-debug" in sys.argv:
 utils.log("debugging started, port will open on 7777 when page loads")
# import profile
 profiler=1

def generate_error_report(e=None):
 fp = stringio.StringIO()
 traceback.print_exc(file=fp)
 message = fp.getvalue()
 del fp
 log(message)
 return message

def makeCleanFunctionName(s):
 if "." not in s:
  return s
 else:
  parts=s.split(".")
  o=""
  o+=parts[0]
  for p in parts[1:]:
   o+=p[0].upper()+p[1:]
 return o

def log2(*args):
 logfh.write(",".join([str(i) for i in args]))
 logfh.write("\n")
 logfh.flush()

class forms(object):
 form_screens=[]

 def save(self):
  pos=self.screen.getyx()
  log("save:pos",pos)
  screenFN=os.tempnam(None,"pywb.scrnfrm.")
  fh=open(screenFN,"wb")
  self.screen.putwin(fh)
  fh.close()
  self.form_screens.append((pos,screenFN))

 def restore(self):
  self.screen.clear()
  pos,fn=self.form_screens.pop(-1)
  fh=open(fn,"rb")
  self.screen=curses.getwin(fh)
  self.screen.move(pos[0],pos[1])
  log("restore:pos",pos)
  fh.close()
  os.remove(fn)

 def gFileBrowser(self,**kw):
  kw['screen']=self.screen
  kw['maxy']=self.maxy
  kw['maxx']=self.maxx
  ret=None
  try:
   self.save()
  except Exception,e:
   generate_error_report()
  try:
   fb=FileBrowser(**kw)
   ret=fb.keyHandler()
  except Exception, e:
   generate_error_report()
  try:
   self.restore()
  except Exception,e :
   generate_error_report()
   log("gDirBrowser:error restoring window")
  return ret

 def gListbox(self,**kw):
  log("gListbox:called:",str(kw))
  kw['screen']=self.screen
  kw['maxy']=self.maxy
  kw['maxx']=self.maxx
  ret=None
  try:
   self.save()
  except Exception,e:
   generate_error_report()
   log("gListbox:error saving")
  try:
   l=Listbox(**kw)
   ret=l.loop()
  except Exception, e:
   generate_error_report()
  try:
   self.restore()
  except Exception,e :
   generate_error_report()
   log("gListbox:error restoring window")
  return ret

 def gEditbox(self,**kw):
  kw['screen']=self.screen
  ret=None
  try:
   self.save()
  except:
   generate_error_report()
  try:
   e=Editbox(**kw)
   ret=e.loop()
  except Exception,e:
   ret=generate_error_report()
  try:
   self.restore()
  except:
   pass
  return ret

 def gTree(self,params):
  self.save()
  g=guiTree.nodeTreeview(params)
  g(self.screen)
  self.restore()

 def gCheckbox(self,**kw):
  kw['screen']=self.screen
  kw['maxy']=self.maxy
  kw['maxx']=self.maxx
  self.save()
  ret=None
  try:
   c=Checkbox(**kw)
   ret=c.loop()
  except Exception,e:
   generate_error_report()
  self.restore()
  return ret

class gui(forms):
 """Holds methods for drawing and painting a screen
"""
 @property
 def x(self):
  return self.curPos[1]
 @x.setter
 def x(self,v):
  self.curPos[1]=v
 @property
 def y(self):
  return self.curPos[0]
 @y.setter
 def y(self,v):
  self.curPos[0]=v

 formElements=set("TEXTAREA,BUTTON,INPUT,SELECT,OPTION".split(","))
 newLineMakerElements=set("BR,P".split(","))
 newLineElements=set("TITLE,HR,LI,TD,H1,H2,H3,H4,H5,H6,BR,P,A,IMG,SOUND,BGSOUND".split(","))
 [newLineElements.add(i) for i in formElements if i!="OPTION"]
 ignoreElements=set("OPTION,NOSCRIPT,SCRIPT,STYLE".split(","))

 def getNextNonChildNode(self,n,inList=None):
  try:
   idx=self.nodes.index((0,n))+1
  except:
   log("err:Node not found:",n.outerHTML,"nodesLen",len(self.nodes))
   return None
  while idx+1<len(self.nodes) and type(self.nodes[idx])==tuple:
   idx+=1
  return idx if not inList else inList.index(self.nodes[idx])

 ws=[chr(i) for i in xrange(1,255)]
#string.whitespace+string.printable
 def getElementText(self,n):
  t=n.nodeName
  t=t if t else 'unnamedNode'
#  if self.ignoreElements.intersection(self.parentNodeNames(n)): return 0,None
  if t=="#text":
   return 0,n.nodeValue.replace("\n"," ").replace("\r"," ").replace("  "," ")
  elif t=="HR":
   return 0,"-"*self.maxy
  elif t=="LI":
   return 1,"* "
  elif t=="IMG":
   if n.alt:
    return 0,"[img] "+n.alt
   elif n.src and n.src.split(":",1)[0]!="data":
    return 0,"[img] "+n.src
#   elif n.hasChildNodes() and n.nodeValue!="":
#    return "[img] "
   else:
    return 0,"[img] unknown"
  elif t=="A":
   x=self.getElementsByTagName(n,"img")
   if x:
    x=x[0]
    x._flags_skip=1
    _,t=self.getElementText(x)
    if t.startswith("[img] "): t=t[6:]
    t="{["+t+"]}"
    return 0,t
   elif n.textContent!="":
#[i for i in self.nodes_flat if i.parentNode==n] and n.textContent!="":
    return 1,"{} "
   elif n.href:
    return 1,"{%s}" % (n.href,)
   else:
    return 1,"{} "
  elif t in self.formElements:
   if t=="INPUT" and n.type and n.type.lower()=="hidden":
    return 1,None
   if n.value:
    v=n.value
    if n.type and n.type.lower()=="password":
     v="*"*len(v)
   if n.checked!=None:
    v="x" if n.checked else " "
   else:
    v=""
   if n.type and n.type.lower() in ("submit","image"):
    return 0,"[submit] %s" % (v,)
   elif n.lable:
    return 0,"[%s] %s" % (n.lable,v,)
   elif n.name:
    return 0,"[%s] %s" % (n.name,v,)
   else:
    return 0,"[unknown form element] %s" % (str(v),)
  elif t[0]!="#":
   return 0,n.nodeValue
  else:
   return 0,None

 def getElementsByTagName(self,root,tag=""):
  tag=tag.upper()
  idx=self.nodes_flat.index(root)
  end=self.getNextNonChildNode(root,self.nodes_flat)
  l=self.nodes_flat[idx:end]
  return [i for i in l if i.tagName==tag]

 def parentNodes(self,p):
  ret=[]
  while p.parentNode!=None:
   p=p.parentNode
   ret.append(p)
  return ret

 def parentNodeNames(self,e):
  e=e.parentNode
  l=[]
  while e!=None:
   try:
    l.append(e.nodeName)
   except:
    break
   e=e.parentNode
  return l

 def getLineText(self,y=None,x=0,length=None):
  y=self.screenPos if y==None else y
  x=self.screenPosX if x==None else x
  length=self.maxy if length==None else length
  return self.screen.instr(y,x,length)

 def getLineNumber(self,absoluteY=0):
  ret=(absoluteY+1)-((self.maxy+1)*self.getScreenNumber(absoluteY)+1)
  log("getLineNumber:absoluteY=%d,line=%d" % (absoluteY,ret,))
  return ret
  l=0
  counter=absoluteY
  subtract=0
  while counter>self.maxy:
   counter-=self.maxy
   subtract+=1
  counter-=subtract
  log("getLineNumber:y=%d,return=%d" % (absoluteY,counter,))
  return counter

 def getScreenNumber(self,absoluteY=0):
  l=-1
  counter=absoluteY
  while counter>=0:
   counter-=(self.maxy+1)
   l+=1
  log("getScreenNumber:y=%d,return=%d" % (absoluteY,l,))
  return l

#returns position in single line-based, zero-based index of a screen, given a screenNumber (current by default) and a lineNumber (0 by default)
#e.g. 2 screens, screen 0 (first screen) has 4 lines, 0-3 inclusive. screen 2, or sn=1, has 4 lines, 0-3 inclusive. line 2 on that second screen is 0,0 0,1 0,2 0,3 1,0 1,1 or 5 (6, because of the zero base)
 def getScreenAbsolutePosition(self,screenNum=None,y=0):
  while y>self.maxy+1:
   y-=(self.maxy+1)
  if screenNum==None: screenNum=self.screenNum
  pos=0
  sn=0
  while sn<screenNum:
   pos+=self.maxy+1
   sn+=1
  pos+=y
  log("getScreenAbsolutePosition:screenNum=%s,y=%s,pos=%s" % (str(screenNum),str(y),str(pos),))
  return pos

  sn=-1
  ln=-1
  lines=self.maxy
  i,j,l=0,0,0
  while i<screenNum:
   l+=self.maxy
   i+=1
  if screenNum>0:
# and y==0:
   l+=screenNum
  j=0
  while j<y:
   l+=1
   j+=1
  return l

 def findNextPositionLocation(self,l):
  for i in l:
   a=self._display.get(i,[])
   if a:
    return a[0][1:3]

 def previousNonIgnoredElement(self,nodes,idx):
  while idx>0 and self.ignoreElements.intersection(self.parentNodeNames(nodes[idx])):
   idx-=1
  return nodes[idx]

 def textOnSameLine(self,nodes,node=None):
  """determine if any actual text is on the current line, excluding text used for formatting or identification"""
#locate node in master list
  x=nodes.index(node) if node!=None else self.nidx-1
  text=0
  while x>0:
#navigate backward through the list
   n=nodes[x]
#skip tuples, because they will not ever have true text
   if type(n)==tuple: x-=1; continue
   d=self._display[n]
#get list of all text strings from this element on the line we are looking for
   l=[j for j in d if j[1]==self.y]
#if nothing in l, then we've moved backward to before our looked-for line, without finding text, so return 0
   if not l: return 0
#get lsit of all non-formatting text
   t=[j for j in l if j[0]==0]
#if nothing in this list, we move to the previous node
   if not t: x-=1; continue
#we've found text by elimination of all non-text and non-looked-for lines
   return 1
  return 0
#   if "".join([i[3] for i in t]).strip(): text=1; return text
#   x-=1
#  return text
# len([j for j in nodes[:self.nidx] if type(j)!=tuple and self.y in [k[0] for k in j._display] and j._nodeText]):
  
 def iterNodes(self,root,endings=0):
  self.js.tmp=root
  lc=[]
  res=self.js.ref.eval("repl.getDocJson(tmp,%d)" % (int(endings),))[0]
  ii=-1
  jm=self.js.ref.map
  jr=self.js.ref.rMap
  for o in res:
   ii+=1
   end,i=o[:2]
#   log(end,i)
   if i in jm:
#    log(id,"in jm,end==",end)
    if end==1:
     lc.append((0,jm[i]))
    else:
     lc.append(jm[i])
    continue
#   log("end:",end)
   if end==0:
#    o[2:]=[urllib.unquote(j) if type(j)==str else j for j in o[2:]]
    nn,v,t,pn=o[2:6]
    nn=nn.upper() if nn[0]!="#" else nn
#    log("pn:",jm.get(pn,"NoKey %s in dict" % (repr(pn),)))
#    log(id,"new node")
    v={"nodeName":nn,"tagName":nn,"nodeValue":v,"nodeType":t,"parentNode":jm[pn],"_flags_skip":0}
    v.update([(o[j],o[j+1]) for j in xrange(6,len(o),2) if o[j] not in v])
#    log("v:",v)
    jc=mozCom.JSClass(root=self.js,name=str(ii),id=i,vars=v)
#{"tagName":nn,"nodeName":nn,"nodeValue":v,"nodeType":t,"parentNode":jm.get(pn,pn),"_flags_skip":0})
#    log("vars2:",repr(jc),jc.ref.vars)
    jm[i]=jc
    jr[(i,ii)]=jc
   else:
#    log(i,"ending node, attempting dict lookup")
    jc=(0,jm[i])
   lc.append(jc)
  return lc

 def makeClosings(self,nodes):
#  log("makeclosings")
  openNodes=[]
  ol={}
  nid=-1
  lenNodes=len(nodes)
  while nid+1<lenNodes:
   lenNodes=len(nodes)
   nid+=1
   n=nodes[nid]
   if type(n)!=tuple and n not in ol:
    openNodes.append((n,self.parentNodes(n)))
    ol[n]=1
    if len(openNodes)>1:
     last=openNodes[-2]
     lastOpeningParents=last[1]
     currentOpeningParents=openNodes[-1][1]
 #    if i in lastOpeningParents:
     count=len(lastOpeningParents)-len(currentOpeningParents)
#     log("count:",count,"lastParents",[i.nodeName for i in lastOpeningParents],"currentParents",[i.nodeName for i in currentOpeningParents],"in",n.nodeName,"last",last[0].nodeName)
     if count>=0 and n.parentNode in lastOpeningParents and not (count==0 and last[0].nodeName==openNodes[-1][0].nodeName=='#text'):
      closings=lastOpeningParents[:count]
#      if count==0: 
      closings.insert(0,last[0])
      closings=[i for i in closings if i.nodeName!="#text"]
#      log("closings",[i.nodeName for i in closings])
      if closings:
       [nodes.insert(nid,(0,i)) for i in closings[::-1]]
       nid-=1
      continue
  _c=nodes[nid]
  c=_c if type(_c)!=tuple else _c[1]
  parents=self.parentNodes(c)
#if not tuple
  if c==_c: parents.insert(0,c)
  [nodes.append((0,i)) for i in parents if i.nodeName!="#text"]
  return nodes

 def paintScreen(self,dirty=None):
#  log("paintScreen")
  self.nidx=-1
  w=self.maxx
  self.y,self.x=0,0
#  log("nodes from doc:"+str(self.dom.document))
  self.dom.document.ref.vars['_flags_skip']=0
  for k in "nodeName,tagName,nodeValue".split(","):
   try:
    self.dom.document.ref.vars[k]=self.dom.document[k]
   except:
    self.dom.document.ref.vars[k]=None
  self.dom.document.ref.vars['parentNode']=None
  try:
   nodes=self.iterNodes(self.dom.document,1)
   nodes=self.makeClosings(nodes)
   self.nodes=nodes
   self.nodes_flat=[i for i in nodes if type(i)!=tuple]
  except:
   generate_error_report()
#  log("got all nodes,",len(nodes),repr([i for i in nodes]))
  last=None
  self.newLineCount=0
  self._display={}
  self.ys={}
  if dirty!=None:
   nodes=nodes[nodes.index(dirty):]
   self.y,self.x=findNextPositionLocation(nodes)
   last=nodes[0].previousSibling
#if a node in nodes is an end marker, it will be a tuple. otherwise, it will be a node
#set all lists for each node in nodes to an empty list, as we are basically clearing all previous positions
  [self._display.__setitem__(j,[]) for j in self.nodes_flat]
  lenNodes=len(nodes)
  nid=-1
  while nid+1<lenNodes:
   self.nidx+=1
   nid+=1
   n=nodes[nid]
#we're at the end of an element
   if type(n)==tuple:
    n,t=n[1],n[1].nodeName if n[1].nodeName else None
    if t in self.newLineElements and t !="A":
#if we need to separate the end of this element from the next, e.g. this is the end of an h1 element, and we have to put a new line, then do so
#skip links, because we can put text after them, and keep from using up excessive vertical pages
     self.y+=1; self.x=0
     currentI=self.nidx
     while currentI+1<lenNodes and type(nodes[currentI])==tuple:
#while we're still in the nodes list, and we are encountering end elements, e.g. </h1></div>, etc
      currentI+=1
#~~
      if type(nodes[currentI])!=tuple:
#if the element after the one we are currently on is not an end element, then add an index to it's _display property, and exit this loop (while loop will break because of finding this node)
       self._display[nodes[currentI]].append((1,self.y,self.x,""))
    continue
#one-time skip of an element
   if n._flags_skip:
    n._flags_skip=0; continue
#maybe make the below an else statement with the tuple check above?
   self._display[n].append((1,self.y,self.x,''))
   i=n.nodeName
#skip script,style,noscript, etc
   if i in self.ignoreElements:
    tnid=self.getNextNonChildNode(n,nodes)
    if tnid!=None:
     nid=tnid-1
     self.nidx=nid
     continue
#if this starting element requires a new line
#it's not a new line type itself, e.g. paragraph or line break
#it's indeed a start element
#basically, if there are nodes with text on our same line, and as above, we're on an element needing a new line, then we supply one. This means that we won't put a new line in unless there is already text on this line, so we won't be inserting multiple blank lines for ending elements and starting new ones.
#for all nodes whose starting position is on the same line as the current node, before this node in the nodes list, and whose text is not blank or whitespace
#   log("elem:",i,type(n),self.textOnSameLine(nodes))
#i not in ("BR","P") and \
   if i in self.newLineElements and \
type(n)!=tuple and \
self.textOnSameLine(nodes):
    self.y+=1; self.x=0; self._display[n].append((1,self.y,self.x,''))
#add second blank line for paragraphs
    if i=="P": self.y+=1; self.x=0; self._display[n].append((1,self.y,self.x,''))
   formatOnly,text=self.getElementText(n)
   if text==None: text=''
   if type(text)==int: text=str(text)
   text=unidecode.unidecode(text)
   text=re.sub(r"^\s+|\s+$",' ',text)
#if text.strip():
   if text.lstrip():
    self.newLineCount=0
#    text=text.replace("\t"," ").replace("\r"," ").replace("\n"," ").replace("  "," ")
    if self.nidx>0:
     lastNode=nodes[self.nidx-1]
#     if type(lastNode)!=tuple and lastNode.nodeName not in ("BR","P"):
#      text=text.lstrip()
    lenT=len(text)
    if (self.x+lenT)<w:
     self._display[n].append((formatOnly,self.y,self.x,text))
     if text: self.ys[self.y]=1
     self.x+=lenT
    elif self.x+lenT>w and lenT<w:
     self.y,self.x=self.y+1,lenT
     self._display[n].append((formatOnly,self.y,0,text))
     if text: self.ys[self.y]=1
    else:
     for t in self.wrapToFit(text, self.maxx, self.x):
      self._display[n].append((formatOnly,self.y,self.x,t))
      if t: self.ys[self.y]=1
      oldY,oldX=self.y,self.x+lenT
      self.y,self.x=self.y+1,0
     if oldX<w: self.y,self.x=oldY,oldX
  self.numLines=self.y
  self.xn=nodes
  return
  try:
   fh=utils.open("logs/screenTextRefresh.txt","wb")
   fh.write(str(self.dom.document))
   fh.close()
  except:
   generate_error_report()

 def writeScreenCoordsToFile(self):
  return
  fh=utils.open("logs/screen.log","wb")
  fh.write(str(self._display))
#+"\n$$$\n")
#   for j in i._display:
#    fh.write(str(j)+"\n")
  fh.write("\n")
  fh.close()

 def showScreen(self,screenNum=None,y=None,absoluteY=None,x=None,force=0):
#  if self.dom.document._display==self.dom.document.childNodes[0]._display: log("displays still the same")
#  [log(i[-3]) for i in inspect.stack()]
  self.writeScreenCoordsToFile()
  _absoluteY=absoluteY
  _screenNum=screenNum
  if absoluteY==None:
   screenNum=self.screenNum if screenNum==None else screenNum
   y=self.screen.getyx()[0] if y==None else y
  else:
   absoluteY=absoluteY
   screenNum=self.getScreenNumber(absoluteY)
   y=self.getLineNumber(absoluteY)
  absoluteY=self.getScreenAbsolutePosition(screenNum=screenNum,y=0)
  x=self.screen.getyx()[1] if x==None else x
  log("showScreen:",absoluteY,screenNum,y,x)
  if _screenNum==self.screenNum and force==0:
   self.screenPos,self.screenPosX=y,x
   log("showScreen:just refreshing and moving. _screenNum=%s, screenNum=%s, y=%s, x=%s" % (str(_screenNum),str(self.screenNum),str(y),str(x),))
   self.screen.move(self.screenPos,self.screenPosX)
   self.screen.refresh()
   self.onFocus()
   return
  self.screen.clear()
  for n in self.nodes_flat: #self.iterNodes(self.dom.document):
#   log("sscr.node:"+n.nodeName)
   for _,nY,nX,t in self._display[n][1:]:
#    log("SSCR:screenNum=%s,nY=%s,nX=%s,t=%s" % (str(screenNum),str(nY),str(nX),str(t),))
    if nY<absoluteY:
     continue
    if nY>absoluteY+self.maxy:
     break
    log("draw",nY-absoluteY,nX,t)
    self.screen.addstr(nY-absoluteY,nX,t)
  self.screenPos,self.screenPosX=y,x
  self.screenNum=screenNum
  self.screen.move(y,x)
  self.screen.refresh()
  self.onFocus()
  self.pagePosition()
  return None

 def closePage(self):
  self.js.gBrowser.selectedTab=self.page
  self.js.gBrowser.visibleTabs.ref.jsrefresh()
  self.js.gBrowser.ref.jsrefresh()
  try:
   self.js.gBrowser.removeCurrentTab()
   self.restoreWindow(id=self.js.Array.indexOf(self.js.gBrowser.visibleTabs.index(self.js.gBrowser.selectedTab)))
  except:
   self.moveWindow()

 def searchPage(self,direction="forward"):
  focus=self.getFocusedElement()
  if direction not in ["previous","next"] or self.searchString=="":
   self.searchString=self.prompt('Search String:',self.entry)
  nodes=self.nodes_flat #self.iterNodes(self.dom.document)
  nodesLength=len(nodes)
  focusIndexO=nodes.index(focus)
  if direction=="backward" or direction=="previous":
   index=-1
   function="rfind"
   nodes=nodes[::-1]
   focusIndex=nodes.index(focus)
   nodes=nodes[focusIndex+1:]+nodes[:focusIndex+1]
  if direction=="forward" or direction=="next":
   index=None
   function="find"
   focusIndex=nodes.index(focus)
   nodes=nodes[focusIndex+1:]+nodes[:focusIndex+1]
   log("searching %d nodes, old size %d, location of current node is %d, old loc was %d" % (len(nodes),nodesLength,focusIndex,focusIndexO,))
  for n in nodes:
   for _,nY,nX,t in self._display[n][1::index]:
    if config.caseSensitiveSearch=="true":
     l=getattr(t,function)(self.searchString)
    else:
     l=getattr(t.lower(),function)(self.searchString.lower())
    if l!=-1:
     log("found element %s at %d,%d" % (str(n),nY,nX,))
     return self.showScreen(absoluteY=nY,x=nX+l)
  self.setStatus("Search String {0} not found.".format(self.searchString))

 def isOnLayoutElement(self,n,sn=None,y=None,x=None):
  """Determine if provided position tripple is located on a coordinate considered to be accessible spacing.
When spacing is added to an element, an extra coord is appended to the beginning of the element.
"""
  sn=self.screenNum if sn==None else sn
  y=self.screenPos if y==None else y
  x=self.screenPosX if x==None else x
  pos=self.getScreenAbsolutePosition(sn,y)
  dd=self._display[n]
  if len(dd)>0 and pos==dd[0][1] and (len(dd)==1 or (len(dd)>1 and dd[0][1]!=dd[1][1])):
   return 1
  return 0

 def getFocusedElement(self,sn=None,y=None,x=None):
  """Given an optional (screenNumber, y, x) tripple, search the tree for the first element whose text is not null, and whose position is consistent with the provided tripple.
No section of the physical screen array should be unattached from an element.
Some sections may have more than one element attached, as each element is attached to a coord on the screen array as it is encountered.
E.g. we find a body element, which goes at 1,0 (we assume title is at 0,0).
Then we find a div element. That div is also at 1,0, and that 1,0 is saved in the div's _display parameter.
Then we find text, "The cow gives brown milk. It's confused."
That text also is marked at 1,0, and extends to 1,len(text).
The next element will be placed at 1,len(text)+1.
If said next text requires a line break, That line break will be attached to that text element.
"""
  sn=self.screenNum if sn==None else sn
  y=self.screenPos if y==None else y
  x=self.screenPosX if x==None else x
  pos=self.getScreenAbsolutePosition(sn,y)
  nodes=self.nodes_flat #self.iterNodes(self.dom.document)
  l=[]
  lenNodes=len(nodes)
  i=lenNodes
  while i-1>0:
   i-=1
   n=nodes[i]
#   log("getDataObject:"+"pos:"+str(pos)+","+str(n.nodeName)+","+str(n._display))
   if self._display[n]==[] or len(self._display[n])==1: l.append(n); continue
   if self._display[n][0][1]<=pos<=self._display[n][-1][1]+1:
    log("searching for pos %d, %d<=%d<=%d" % (pos,self._display[n][0][1],pos,self._display[n][-1][1],))
    for frm,nY,nX,t in self._display[n]:
#     log("displayInNode:pos="+str(pos)+",ny="+str(nY)+",x="+str(x)+",nX="+str(nX)+",nx+len(t)="+str(nX+len(t)+1))
     if (t!='' or (t=='' and frm==0)) and nY==pos and (nX<=x<=nX+len(t)+1): # or t.strip()==''):
#      log("getFocusedElement:returning "+n.nodeName+","+str(n),nY,nX,pos,y,x)
      return n
   if self._display[n][0][1] < pos:
    if len(l)>0:
     return l[-1]
  i=len(nodes)
  while i-1>0:
   i-=1
   n=nodes[i]
   if len(self._display[n])>0 and self._display[n][-1][1]==pos and self._display[n][-1][2]==x:
    return n

 def findElement(self,tag="",attrs={},direction="forward"):
  """given a list of tags and an optional dictionary of attributes, search the dom tree for the requested tag(s).
Pull all nodes as a list. Move through the list, skipping nodes whose position (physical or tree-logical) would preclude them from being candidates.
Return the first matching node.
"""
  if type(tag)==str: tag=[tag]
  tag=[i.upper() for i in tag]
  currentNode=self.getFocusedElement()
  nodes=self.nodes_flat #self.iterNodes(self.dom.document)
  y,x,sn=self.screenPos,self.screenPosX,self.screenNum
  absoluteY=self.getScreenAbsolutePosition(screenNum=sn,y=y)
  idx=nodes.index(currentNode)
  lenNodes=len(nodes)
  if direction=="forward":
   idx-=1
   while idx+1<lenNodes:
    idx+=1
    i=nodes[idx]
    if i.nodeName not in tag:
     continue
    try:
     d=self._display[i][1]
    except:
      continue
    nY,nX=d[1:3]
    if (nY>absoluteY):
# or (nY==absoluteY and nX>x):
     log("findElement:"+str(y)+","+str(x)+":"+str(self._display[i][1])+","+str(i))
     return i
  if direction=="backward":
   while idx>0:
    idx-=1
    i=nodes[idx]
    if i.nodeName not in tag:
     continue
    try:
     d=self._display[i][1]
    except:
      continue
    nY,nX=d[1:3]
    if (nY<absoluteY): # or (nY==absoluteY and nX<x and currentNode.parentNode.parentNode!=i):
     log("findElement:"+str(y)+","+str(x)+":"+str(self._display[i][1])+","+str(i))
     return i 

class ActiveWindow(gui):
 """Manages the active window (the single set of screens available to the user for one webpage)
similar in concept to a tab in Firefox
"""
 def printStructure(self,x):
  output=""
  for i in x:
   if type(i)!=tuple and i.tagName!="#text":
    output+="<%s>\n" % (i.tagName,)
   elif type(i)!=tuple and i.tagName=="#text":
    output+=i.nodeValue.strip()+"\n"
   else:
    output+="</%s>\n" % (i[1].tagName,)
  return output

 @property
 def f(self):
  return self.getFocusedElement()

 def exit(self,*a,**kw):
  try:
   curses.echo(1)
   self.screen.keypad(0)
   self.screen.nodelay(0)
   curses.nocbreak()
  except Exception,e:
   log("exit:err",e)
  sys.exit()

 quit=exit

 def __init__(self,screen,jsQ=None,jsRoot=None,start_url=""):
  """initialize the main window
jsQ points to the queue where JS generated events are sent
jsRoot points to the root class of js
"""
  log("thread:init:activeWindow")
  self.lastMessage=""
  self.daemon=1
  self.start_url=start_url
  self.codeHist=[]
  self.events=[]
  self.local_vars="numLines,_display,nodes,nodes_flat,screenNum,screenPos,screenPosX,url".split(",")
  self.jsQ=jsQ
  self.js=jsRoot
  self.keys=config.mainWindowKeys
  self.windows=[]
  self.windowVars={}
  self.windex=-1
  self.screen = screen
  self.screen.nodelay(1)
  self.screen.keypad(1)
  curses.raw(1)
  curses.noecho()
  self.initVars()
  self.run()

 def initVars(self):
  self.maxy,self.maxx=self.screen.getmaxyx()
  self.curPos=[0,0]
  self.status=self.maxy-1
  self.entry=self.status-1
  self.searchString=""
  self.maxy=self.entry-1
  self.screenPos=0
  self.screenPosX=0
  self.screenNum=0

 def downloadComplete(self,d):
  self.setStatus('The file "%s" has finished downloading.' % (d.get("filename","unavailable"),))

 def downloadStatus(self,d):
  if "progress" in d:
   p=d['progress']
   perc=(p[0]/p[1] if p[1]!=0 else 0.1)*100
   if str(perc).split(".",1)[0].endswith("0") and str(perc).split(".",1)[-1].startswith("00"):
    self.setStatus("%s, %s percent complete" % (str(perc),d['filename'],))

 def urlSuccess(self,d):
  self.setStatus("loaded,%s" % (d['url'],))
  self.url=d['url']
#  self.timer_q=Queue.Queue()
#  self.timer_events=[]
  if hasattr(self,"dom"):
   del self.dom

 def noNext(self, s):
   if config.beeps=='true':
     curses.beep()
   if config.limitMessages=='true':
     self.setStatus("No more %s" % s)

 def noPrev(self, s):
   if config.beeps=='true':
     curses.beep()
   if config.limitMessages=='true':
     self.updateStatus("No previous %s" % s)

 def onStateChange(self,e):
  """Ignore the first onStateChange called on the about:blank document"""
#  old=self.dom.document.ref.id
#  self.dom.document.ref.jsrefresh()
#  if self.dom.document.ref.id!=old:
#   return
  self.events.append(e)
#  self.setStatus("event onStateChange")
#  self.page.linkedBrowser.ref.jsrefresh()
#  self.dom=self.page.linkedBrowser.contentDocument.defaultView
#  self.pageRefreshData()
  self.restoreWindow(self.page)

 def tabSelect(self,e):
  """We've switched to a new tab, and signaled firefox appropriately"""
  self.page.linkedBrowser.ref.jsrefresh()
  if self.page==e.target:
   return
  self.page=e.target
  self.restoreWindow(self.page)

 def load(self,e):
  """trigger on page loads. currently replaced with the onStateChange event to account for the goBack method's lack of triggering of the load event."""
  return
  self.page.linkedBrowser.ref.jsrefresh()
  if e.target.location.href=="about:blank":
   return
  log("page.linkedBrowser.contentDocument",self.page.linkedBrowser.contentDocument,"e.target",e.target)
  if e.target.defaultView==e.target.defaultView.top and self.page.linkedBrowser.contentDocument==e.target:
   self.events.append(e)
   self.dom=e.target.defaultView
   self.dom.ref.jsrefresh()
   log("setting dom to %s" % (str(self.dom),))
   self.setStatus("page %s loaded" % (self.dom.location.href,))
   self.pageRefreshData()

 def onStatusChange(self,e):
  """print status messages to status bar"""
  time.sleep(0.01)
  m=e.aMessage
  if self.lastMessage!=m:
   self.setStatus(m)
   self.lastMessage=m

 def event(self,e):
  """triggers on any event not covered above"""
  self.setStatus(str(e))

 def pageRefreshData(self):
  """create visual layout of webpage data and place that representation on screen
webpage has been received, processed, turned into a dom construct, and had it's load script method run.
now we display the webpage by scanning the nodes for text, and displaying that text layout to screen.
"""
  if profiler==1:
   try:
    self.setStatus("debugger enabled")
    utils.debugger(locals=locals())
    self.setStatus("debugger disabled")
   except:
    pass
  try:
   pass #utils.open("logs/loadedPageText.txt","wb").write(str(self.dom.document.body.parentNode.innerHTML))
  except Exception,e:
   generate_error_report()
  if self.dom==None:
   self.setStatus("waiting for dom...")
   return
  self.setStatus("painting")
  self.screen.clear()
  a=time.time()
  self.paintScreen()
  b=time.time()
  log("painted, time %s" % (str(b-a),))
  self.setStatus("showing screen")
  self.showScreen(screenNum=0,y=0,force=1)
  self.htmlHttpCommands()

 def htmlHttpCommands(self):
  """might check for refresh or url-change requests here, though those should come through events"""
  return

 def toggleStatusBar(self,*l):
  """toggles status bar, limiting displayed text
toggles status bar (the bottom line of the window) to prevent text from changing the window state.
used, e.g. when reading a webpage as a whole document.
"""
  if not hasattr(self,"statusbar"):
   self.statusbar=1
  self.statusbar=-1*self.statusbar
 
 def nextLink(self,*args):
   x=self.moveToElem(self.findElement("A",direction="forward"))
   log("nextLink,%d,%d,%d" % (self.screenNum,self.screenPos,self.screenPosX,))

 def prevLink(self,*args):
  x=self.moveToElem(self.findElement("A",direction="backward"))
  log("prevLink,%d,%d,%d" % (self.screenNum,self.screenPos,self.screenPosX,))

 def jumpToLine(self,lineNumber):
  self.showScreen(y=self.getLineNumber(lineNumber),screenNum=self.getScreenNumber(lineNumber))

 def moveToElem(self,target):
#  log("target:",target)
  if target==None: return
  td=[i[1:3] for i in self._display[target] if len(i)>=4 and i[3].strip()!='']
  if len(td)==0:
   td=self._display[target][-1][1:]
  else:
   td=td[0]
  screenNum,y,x=self.getScreenNumber(td[0]),self.getLineNumber(td[0]),td[1]
  log("moveToElem:","screenNum",screenNum,"y",y,"x",x,str(target))
  self.showScreen(screenNum=screenNum,y=y,x=x)
  return td

 def wrapToFit(self, text, width=80, indent=None):
  log("wrapToFit:",text,width,indent)
  start,end=0,0
  lines=[]
  textLength=len(text)
  if indent!=None:
   end=width-indent
  else:
   end=width
  while end<textLength:
   if text[end]==' ':
    lines.append(text[start:end])
    start=end+1
    end=start+width
   if end==start:
    lines.append(text[start:start+width])
    start=start+width
    end=start+width
   end-=1
  lines.append(text[start:])
  return lines
 
 def forceCachelessPageRefresh(self):
  """send request to refresh the page and bypass the firefox cache"""
  if hasattr(self,"url"):
   self.dom.location.href=url
  else:
   self.setStatus("No page open.")

 def openLocalFile(self):
  fn=self.gFileBrowser()
  self.dom.location.href=fn

 def navigate(self,c=""):
  go=self.prompt("url: ",self.entry, history=None)
  if go=='': return
  self.dom.location.href=go

 def navigateInNewWindow(self,url=None):
  if url==None:
   url=self.prompt("url (new window):",self.entry, history=self.goHistory)
  self.newWindow(url)

 def goBack(self):
  if not self.page.linkedBrowser.canGoBack:
   return self.setStatus("no page to go back to in this tab")
  return self.page.linkedBrowser.goBack()
#  self.dom.defaultView.history.back()

 def urlError(self,d):
  url=d['url']
  err=d['error']
  fErr=repr(err)
  self.updateStatus("Error occured,%s,%s" % (err,url,))
  if "ssl" in fErr.lower():
   if url.split("//",1)[-1].split("/",1)[0] in self.noverify:
    self.pageQ.put(dict(name="go",url=url,verify=False))
    return
   fErrPlain=fErr.strip("(").strip(")").replace("(",".").replace(")",".").replace("..",".")
   ret=self.gListbox(values=["continue and save","cancel","continue"],title="Ignore SSL Certificate Verification security warning?",status=fErr)
   if "continue" in ret[-1]:
    self.pageQ.put(dict(name="go",url=url,verify=False))
   self.noverify.append(url.split("//",1)[1].split("/",1)[0])
   self.updateStatus("")

 def isInElement(self,e,n=None):
  if e in self.parentNodeNames(self.getFocusedElement()): return 1

 def findNextText(self,mx=-1):
  return self.findElement("#text",direction="forward")

 def findPrevText(self,mx=-1):
  return self.findElement("#text",direction="backward")

 def rl (self, history=None, default=None, echo='true', length=None):
  """
prompt for user input, with bindings to that of the default readline implimentation
history: a list of strings which constitutes the previously entered set of strings egiven to the caller of this function during previous calls
default: the default text, entered as if the user had typed it directly
echo: acts as a mask for passwords (set to ' ' in order to not echo any visible character for passwords)
length: the maximum length for this text entry (element.attr=maxlength is the corresponding html attribute)
"""
  y,startX=self.screen.getyx()
  if history!=None:
   current=theEnd=len(history)
   theEnd-=1
  insertMode='true'
  ret=''  # return complete line buffer
  ptr=0
  x=startX
  self.screen.nodelay(0)
  curses.raw(1)
  if default!=None:
   ret=default
   self.screen.addstr(y, startX, echo*len(ret) if echo!='true' else ret)
  while 1:
   c=self.screen.getch()
#   self.setStatus("KeyPress "+str(c))
   if curses.ascii.isprint(c):
    if ptr==len(ret):
     ret+=chr(c)
     if echo!='true': c=echo
     self.screen.addch(y, x, c)
     if x == self.maxx-1:
      tmp=self.screen.instr(y, startX+1)
      self.screen.clrtoeol()
      self.screen.addstr(y, startX, tmp)
    elif insertMode=='true':
     ret=ret[0:ptr]+chr(c)+ret[ptr:]
     if echo!='true': c=echo
     self.screen.insch(y, x, c)
    else:
     ret=ret[0:ptr]+chr(c)+ret[ptr+1:]
     if echo!='true': c=echo
     self.screen.addch(y, x, c)
    if x < self.maxx-1: x += 1
    if length!=None and ptr==length: break
    ptr+=1
   elif c == 3:  # ^C
    self.setStatus("Input aborted!")
    ret=''
    break
   elif c == 10:  # ^J newline
    ret.rstrip(' ')
    break
   elif c in (1, 262):  # ^A, Home key
    x=startX
    ptr=0
    self.screen.addstr(y, startX, ret)
   elif c in (5, 360):  # ^E, End key
    ptr=len(ret)
    if ptr+startX > self.maxx-1:
     self.screen.addstr(y, startX, ret[-self.maxx+1+startX:])
     self.screen.addch(y, self.maxx-1, ' ')
     x=self.maxx-1
    else:
     x=startX+ptr
   elif c in (2, 260):  # ^B, left arrow
    if x-1 >= startX: 
     x -= 1
     ptr -= 1
    elif ptr>0:
     ptr -= 1
     self.screen.addstr(y, startX, ret[ptr:])
    elif config.beeps=='true':
     curses.beep()
   elif c in (6, 261):  # ^f, right arrow
    if x+1 <= startX+len(ret) and x+1 <= self.maxx-1:
     x+=1
     ptr += 1
    elif ptr < len(ret):
     ptr += 1
     self.screen.clrtoeol()
     self.screen.addstr(y, startX, ret[ptr+1-self.maxx+startX:ptr+1])
    elif config.beeps=='true':
     curses.beep()
   elif c == 259:  # Up arrow
    if not history: #history will return non-zero if it has content
     self.setStatus("No history to move up through.")
     if config.beeps=='true':
      curses.beep()
    elif current>0:
     current-=1
     ret=history[current]
     self.screen.clrtoeol()
     self.screen.addstr(y, startX, ret)
    elif config.beeps=='true':
     curses.beep()
   elif c == 258:  # Down arrow
    if not history:
     self.setStatus("No history to move down through.")
     if config.beeps=='true':
      curses.beep()
     continue
    else:
     current+=1
     if current<=theEnd:
      ret=history[current]
     else:
      ret=''
      current-=1  # Don't want it running away.
      if config.beeps=='true':
       curses.beep()
    self.screen.clrtoeol()
    self.screen.addstr(y, startX, ret)
#   elif c == 18:  # ^R Reverse search for Brandon
   elif c in (8, 263):  # ^H, backSpace
    if x > startX: 
     self.screen.delch(y, x-1)
     ret=ret[0:ptr-1]+ret[ptr:]
     x -= 1
     ptr-=1
   elif c in (4, 330):  # ^D, delete
    self.screen.delch(y, x)
    ret=ret[0:ptr]+ret[ptr+1:]
   elif c == 331:  # insert
    if insertMode=='true':
     insertMode='false'
     self.setStatus("Insert Mode off")
    else:
     insertMode='true'
     self.setStatus("Insert Mode On")
   elif c == 21:  # ^U
    x = startX
    ptr=0
    ret=''
    self.screen.move(y, startX)
    self.screen.clrtoeol()
   elif c == 11:  # ^K
    self.screen.clrtoeol()     
    ret=ret[0:ptr]
    self.screen.addstr(y, startX, ret)
   self.screen.move(y, x)
   self.screen.refresh()   
#   self.setStatus("x="+str(x)+" ptr="+str(ptr))
  self.screen.nodelay(1)
  curses.raw(1)
  curses.noecho()
  if history!=None and ret:
   history.append(ret)
  return ret

 def prompt(self,prompt=":",y=None, history=None,default=None,echo='true'):
  pos=self.screen.getyx()
  if y==None: y=self.status
  self.screen.move(y,0)
  self.screen.clrtoeol()
  self.screen.addstr(y, 0, prompt)
  self.screen.move(y, len(prompt)+1)
  c=""
  c=self.rl(history=history,default=default,echo=echo)
  self.setStatus(prompt+c)
  self.screen.move(y,0)
  self.screen.clrtoeol()
  self.screen.move(pos[0],pos[1])
  self.screen.refresh()
  return c

 def onFocus(self,*args):
  d=self.getFocusedElement()
  if d==None:
   return None
  log("onFocus:d="+str(d)+",parentNodeNames="+str(self.parentNodeNames(d)))
  if d.nodeName=="A":
   p=d
  elif not self.isOnLayoutElement(d) and "A" in self.parentNodeNames(d):
   p=d.parentNode
   while p.nodeName!="A": p=p.parentNode
  else:
   return self.setStatus("")
  if p.hasAttribute("href"):
   url=p.href
  else:
   url=None
  if url!=None:
   self.setStatus(url)
  else:
   self.setStatus("")

 def addToDownloads(self,url=None):
  return self.setStatus("downloading is not currently available")

 def execute(self):
  d=self.getFocusedElement()
#  log("execute:focus:",str(d),repr(d))
#  d.click()
  if "A" in self.parentNodeNames(d):
   log("execute:linkFound:",d)
   while d.nodeName!="A":
    d=d.parentNode
  if (d.nodeName=="INPUT" and d.hasAttribute("type") and d.getAttribute("type") in ("button","reset","submit","image")) or (d.nodeName=="BUTTON"):
#   d.click()
#   if d.form.evt_submit():
   return d.click()
  if self.formElements.intersection(self.parentNodeNames(d)):
   while d!=None and d.nodeName in self.formElements:
    d=d.parentNode
  if d.nodeName in self.formElements:
   try:
    return self.handleFormInput(d)
   except Exception,e:
    return generate_error_report()
  if d.nodeName=="A" and "#" in d.href and d.href.split("#",1)[0]==d.ownerDocument.location.href.split("#",1)[0]:
   anc=d.href.split("#",1)[-1]
   if anc:
    log("looking for anchor",anc)
    x=self.dom.document.getElementById(anc)
    if x!=None:
     return self.moveToElem(x)
  if d.nodeName=="A":
   url=d.href
   log("execute: "+url)
   d.click()
#   self.dom.location.href=url
   return

 def handleFormInput(self,element):
  log("handleFormInput",element)
  e=element
  baseForm=e.form
#parentNodes(name="form",count=1)
#  self.setStatus("hfi:got base form")
  while e!=None and e.nodeName not in self.formElements:
   e=e.parentNode
  if e.nodeName=="OPTION":
#   self.setStatus("HFI:option found")
   e=self.parentNodes(e,name="select",count=1)
  if e.nodeName=="SELECT":
#   self.setStatus("HFI:select")
   opts=e.options
#getElementsByTagName("option")
   opts=[(i,i.textContent.strip()) for i in opts]
   self.setStatus("gListbox,running")
   ret=self.gListbox(title=e.name,values=opts,default=0)
   e.value=ret[0].value
   log("ret:",ret)
   log("form:",e.value)
  elif e.nodeName=="INPUT" and e.type=="text":
   ret=self.prompt(default=e.value)
#self.gEditbox(default=e.value)
   e.value=ret
  elif e.nodeName=="INPUT" and e.type=="password":
   ret=self.prompt(default=e.value,echo="*")
   e.value=ret
  elif e.nodeName=="TEXTAREA":
   ret=self.gEditbox(default=e.textContent)
   e.innerHTML=ret
  elif e.nodeName=="INPUT" and e.type=="radio":
#   self.setStatus("HFI:radio button")
   opts=[i for i in self.getElementsByTagName(baseForm,"input") if i.type=="radio" and i.name==e.name]
   checked=[i for i in opts if i.checked==1]
   checked=0 if len(checked)==0 else opts.index(checked[0])
   opts=[(i,i.value.strip()) for i in opts]
   ret=self.gListbox(title=e.name,values=opts,default=checked)
   log("radio:ret:",ret)
   if ret!=None:
    ret[0].checked=1
    [setattr(o,"checked",0) for o,p in opts if o!=ret[0]]
  elif e.nodeName=="INPUT" and e.type=="checkbox":
#   self.setStatus("HFI:checkbox")
   ret=self.gCheckbox(title=e.name,values=[e.name],checked=e.checked)
   e.checked=ret
  else:
   ret=self.gEditbox(default=e.value,type=e.type)
   e.value=ret
  self.paintScreen()
  self.showScreen()

 def onPositionChange(self):
  self.onFocus()
#  log(str(("screenNum",self.screenNum,"screenPos",self.screenPos,"screenPosX",self.screenPosX)))

 def nextLine(self,*args):
  self._nextLine()
  self.onPositionChange()

 def nextChar(self,*args):
  self._nextChar()
  self.onPositionChange()

 def prevChar(self,*args):
  self._prevChar()
  self.onPositionChange()

 def prevLine(self,*args):
  self._prevLine()
  self.onPositionChange()

 def _nextChar(self,*args):
  self.screenPosX+=1
#~~
  if self.screenPosX>=self.maxx or self.screenPosX>len(self.screen.instr(self.screenPos,0,self.maxx).strip()):
   self.screenPosX=0
   self.nextLine()
  else:
   self.screen.move(self.screenPos,self.screenPosX)

 def _prevChar(self,*args):
  self.screenPosX-=1
  log("sX="+str(self.screenPosX))
  if self.screenPosX<0:
# or self.screenPosX>len(self.screen.instr(self.screenPos,0,self.maxx).strip()):
   log("sX<0,sX="+str(self.screenPosX))
   self.screenPosX=self.maxx-1
   log("sXNowEquals"+str(self.screenPosX))
   self.prevLine()
   log("sXWithPrevLine,sX="+str(self.screenPosX))
   curLineText=self.screen.instr(self.screenPos,0,self.maxx).strip()
   if self.screenPosX>len(curLineText):
    log("sX@%d,lenOfText@%d" % (self.screenPosX,len(curLineText),))
    self.screenPosX=len(curLineText)
    #remember to move to end of current string, since we're moving toend of current line text
  self.screen.move(self.screenPos,self.screenPosX)

 def _nextLine(self,*args):
  log("_nextLine",self.screenPos,self.screenPosX)
  self.screenPos+=1
  if self.screenPos>self.maxy and self.screenPos*self.screenNum<self.numLines:
   log("end of screen, moving to next screen.")
   self.screenPos=0
   self.nextScreen()
   log("screen,line",self.screenNum,self.screenPos)
  elif self.getScreenAbsolutePosition(y=self.screenPos)>self.numLines:
#self.getFocusedElement(y=self.screenPos-1)._display[-1][0]:
#>=self.numLines:
#self.iterNodes(self.dom.document)[-1]._display[-1][:2]==self.getScreenAbsolutePosition(self.screenNum,self.screenPos):
   log("At or past end of document.\nscreen,line,",self.screenNum,self.screenPos)
   self.screenPos-=1
   self.setStatus("EndOfPage,%d,%d,$url" % (self.screenNum,self.screenPos,))
  else:
   log("moving cursor from %d to %d, on screen %d." % (self.screenPos-1,self.screenPos,self.screenNum,))
   self.screen.move(self.screenPos,self.screenPosX)
  self.screen.refresh()

 def _prevLine(self,*args):
  log("_PrevLine",self.screenNum,self.screenPos,self.screenPosX)
  self.screenPos-=1
  if self.screenPos<0 and self.screenNum>0:
   self.screenPos=self.maxy
   self.prevScreen()
  elif self.screenNum==0 and self.screenPos<=0:
   self.screenPos=0
   self.setStatus("StartOfPage,%d,%d,$url" % (self.screenNum,self.screenPos,))
   self.screen.move(self.screenPos,self.screenPosX)
   self.noPrev('lines')
  elif self.screenPos>=0:
   self.screen.move(self.screenPos,self.screenPosX)

 def nextScreen(self,*args):
  log("_nextScreen",self.screenNum,self.screenPos,self.screenPosX)
  self.screenNum+=1
  if (self.maxy+1)*self.screenNum<self.numLines:
    self.screenPos=0
    self.screenPosX=0
    self.screen.move(self.screenPos,self.screenPosX)
    self.showScreen()
    self.screen.refresh()
    log("nextScreen",self.screenNum,self.screenPos)
  else:
   log("nextScreen At  end of page.",self.screenNum,self.screenPos)
   self.screenNum-=1
   self.noNext('screens')
  self.pagePosition()

 def prevScreen(self,*args):
   if self.screenNum==0:
     log("prevScreen at first screen of page",self.screenNum,self.screenPos)
     self.noPrev('screens')
   else:
     self.screenNum-=1
     self.screenPos=self.maxy
     self.screenPosX=len(self.getLineText().strip())
     self.showScreen()
     self.screen.move(self.screenPos,self.screenPosX)
     self.screen.refresh()
     log("prevScreen",self.screenNum,self.screenPos)

 def topOfScreen(self):
  self.screenPos=0
  self.screenPosX=0
  self.screen.move(self.screenPos,self.screenPosX)

 def bottomOfScreen(self):
  self.screenPosX=0
  if self.maxy*(self.screenNum+1)<self.numLines:
    self.screenPos=self.maxy
    self.screen.move(self.screenPos,0)
  else:
    self.screenPos=self.numLines-self.maxy*self.screenNum-1
    self.screen.move(self.screenPos,0)
  log("BottomOfScreen",self.screenPos,self.screenNum)

 def topOfPage(self):
  if self.screenNum!=0:
    self.screenNum=0
    self.screenPos=0
    self.screenPosX=0
    self.showScreen()
  self.topOfScreen()
  log("topOfPage",self.screenPos,self.screenNum)

 def bottomOfPage(self):
   if self.numLines<self.maxy:
     self.bottomOfScreen()
   else:
     self.screenNum=self.numLines/self.maxy
     self.showScreen()
     self.bottomOfScreen()
     log("bottomOfPage",self.screenPos,self.screenNum)

 def startOfLine(self):
   self.screenPosX=0
   self.screen.move(self.screenPos,self.screenPosX)
   log("startOfLine",self.screenPos,self.screenPosX)

 def endOfLine(self):
  self.screenPosX=len(self.screen.instr(self.screenPos,0,self.maxx).strip())-1
  log("endOfLine","screen pos:",self.screenPos,"screen pos X:",self.screenPosX,"screen num:",self.screenNum)
  self.screen.move(self.screenPos,self.screenPosX)

 def pagePosition(self):
  try:
   self.screen.move(self.entry,0)
   self.screen.clrtoeol()
   if config.pagePosition=='pages':
     self.screen.addstr("Page %s of %s" % (self.screenNum+1,self.numLines/self.maxy+1))
   elif config.pagePosition=='percentage':
     self.screen.addstr("%d%% of %d lines." % (((self.screenNum+1)*self.maxy*100)/self.numLines,self.numLines))
   self.screen.move(self.screenPos,self.screenPosX)
   log("pagePosition",config.pagePosition)
   self.screen.refresh()
  except:
   self.setStatus("Page position error")

 def updateStatus(self,*args,**kw):
  self.setStatus(*args,**kw)

 def setStatus(self,txt,*l):
  if isinstance(txt,list): txt=",".join([str(i).strip() for i in txt])
  if l: txt+=" "+" ".join(l)
  if not isinstance(txt,str): txt=str(txt)
  txt=txt.encode('utf-8')
  log("status:",txt)
  cur=self.screen.getyx()
  self.screen.move(self.status,0)
  self.screen.clrtoeol()
  s=txt[:self.maxx-1]
#  log("statusInfo:",self.status,"sText",s,"pos",cur)
  try:
   self.screen.addstr(self.status,0,s)
  except:
   generate_error_report()
   self.setStatus("error")
  self.screen.move(cur[0],cur[1])
  self.screen.refresh()

 def saveWindow(self):
  if hasattr(self,"page"):
   p=self.page
   self.windowVars[p]={}
   d=self.windowVars[p]
   [d.__setitem__(i,getattr(self,i,None)) for i in self.local_vars]

 def restoreWindow(self,w=None):
  self.page=w
  self.page.ref.jsrefresh()
  self.page.linkedBrowser.ref.jsrefresh()
  self.dom=self.page.linkedBrowser.contentDocument.defaultView
  self.dom.ref.jsrefresh()
  try:
   d=self.dom.document
  except:
   self.setStatus("No document object to display")
   return
  if w in self.windowVars:
   [setattr(self,k,v) for k,v in self.windowVars[w].items() if k in self.local_vars]
   if not (self._display and self.nodes):
    a=time.time()
    self.paintScreen()
    b=time.time()
    log("painted, time %s" % (str(b-a),))
   self.showScreen(force=1)
  else:
   self.initVars()
   a=time.time()
   self.paintScreen()
   b=time.time()
   log("painted, time %s" % (str(b-a),))
   self.showScreen(force=1)

 def execCode(self):
  p=self.prompt("code:",history=self.codeHist)
  try:
   if ":"==p[0]:
    a=self.js.ref.eval(p[1:])
   else:
    if "=" in p and not [i for i in p.split("=",1)[0] if i not in string.digits+string.letters+"_."]:
     exec p
     a=eval("str("+p.split("=",1)[0].strip()+")")
    else:
     a=eval(p)
   self.setStatus(str(a).split("\n",1)[0])
  except Exception,e:
   self.setStatus("Exc:"+str(e))
   generate_error_report()

 def newWindow(self,url="about:blank"):
  p=self.js.gBrowser.addTab(url)
  p.url=url
  self.moveWindow(id=self.js.Array.indexOf(self.js.gBrowser.visibleTabs,p))

 def nextWindow(self):
  self.moveWindow(1)

 def prevWindow(self):
  self.moveWindow(0)

 def moveWindow(self,direction=1,id=None):
#~~
  self.saveWindow()
  if id and 0<=id<self.js.gBrowser.visibleTabs.length:
   self.page=self.js.gBrowser.visibleTabs[id]
   self.windex=id
   self.restoreWindow(self.page)
   return
  if direction==1:
   if self.windex>=self.js.gBrowser.visibleTabs.length-1:
    self.windex=-1
   self.windex+=1
  else:
   if self.windex<=0:
    self.windex=self.js.gBrowser.visibleTabs.length
   self.windex-=1
  self.page=self.js.gBrowser.visibleTabs[self.windex]
  self.restoreWindow(self.page)

 def handleLocalKey(self,k,*args):
  if k in self.keys:
   try:
    exec(self.keys[k])
   except Exception,e:
    fp = stringio.StringIO()
    traceback.print_exc(file=fp)
    message = fp.getvalue()
    del fp
    v=str(e)+"\n"+str(message)
    log("KBDError",v)
#~~
    self.setStatus("KeyboardError:%s" % (e,))

 def handleEvent(self,ev):
#  self.events.append(ev)
  log("mainWindow:event:",str(ev))
  try:
   n=ev['t']
   n=n[0].lower()+n[1:]
   m=getattr(self,n)
   try:
    return m(*ev['a'])
   except Exception,e:
    log("eventError:",e)
    generate_error_report()
  except:
   try:
    return self.event(ev)
   except Exception,e:
    generate_error_report()

 def event(self,e):
  self.events.append(e)
  if e.get("m","")=='w': return
  self.setStatus("event %s" % (e.get("t","noName"),))

 def key(self,k):
  self.setStatus("key %s invalid." % (str(k),))

 def run(self):
  if not hasattr(self,"page"):
   if getattr(self,"start_url","")!=None:
    self.newWindow(getattr(self,"start_url",config.get("homepage","http://bmcginty.hopto.org/form.html")))
   else:
    self.moveWindow(id=0)
  while 1:
   time.sleep(0.01)
   self.js.ref.recv(0.01)
   c=self.screen.getch()
   if c!=-1:
    if c in self.keys:
     self.handleLocalKey(c)
    elif c in config.g_keys:
     self.saveWindow()
     exec(g_keys[c])
     self.restoreWindow()
   try:
    event=self.jsQ.get(block=0)
   except:
    event=None
   if event!=None:
    self.handleEvent(event)
    continue

def main():
 global reg_space,formElements,config
 warnings.simplefilter("ignore")
 reg_space=re.compile("["+string.whitespace+"]+") 
 formElements=set("SUBMIT,INPUT,OPTION,SELECT,TEXTAREA".split(","))
#replace with parser for name.x.y.z=value, resolvable with config.name.x.y.z
#set dom to parse js
 config=utils.attrDict()
 config.logging=1
 config.homepage="http://www.bmcginty.hopto.org/form.html"
 config.pagePosition="percentage"
 config.caseSensitiveSearch="false"
 config.showInstantPage=0
 config.g_keys={}
 config.mainWindowKeys={
ord("`"):"self.nextWindow()",
ord("q"):"self.quit()",
ord("\n"):"self.execute()",
curses.KEY_DOWN:"self.nextLine()",
curses.KEY_UP:"self.prevLine()",
curses.KEY_RIGHT:"self.nextChar()",
curses.KEY_LEFT:"self.prevChar()"
}


 
def main2():
 global quitFlag
 quitFlag=0
 j,q=mozCom.initCliFox()
 curses.wrapper(ActiveWindow,jsQ=q,jsRoot=j,start_url=[i for i in sys.argv if ":" in i][0] if [i for i in sys.argv if ":" in i] else None)

main()
if os.path.exists('/etc/wb.conf'): execfile('/etc/wb.conf')
if os.path.exists('./wb.conf'): execfile('./wb.conf')
if not os.path.exists(os.path.expanduser('~/.wb/')):
 os.mkdir(os.path.expanduser('~/.wb'))
if os.path.exists(os.path.expanduser('~/.wb/wb.conf')):
 execfile(os.path.expanduser('~/.wb/wb.conf'))
if not os.path.exists(os.path.expanduser('~/.clifox/')):
 os.mkdir(os.path.expanduser('~/.clifox'))
if os.path.exists(os.path.expanduser('~/.clifox/clifox.conf')):
 execfile(os.path.expanduser('~/.clifox/clifox.conf'))

if __name__=='__main__':
 main2()
